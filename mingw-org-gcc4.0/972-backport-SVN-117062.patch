From ad16c2fe8b753b7c9b98f65c127039451623bd3c Mon Sep 17 00:00:00 2001
From: Roger Sayle <roger@eyesopen.com>
Date: Tue, 19 Sep 2006 21:25:28 +0000
Subject: backport SVN117062

  2006-09-19  Roger Sayle  <roger@eyesopen.com>

	PR middle-end/4520
	Backport from mainline
	* cselib.c (cselib_hash_rtx): Avoid hashing on the address of labels
	and symbols.  Instead use the implementation from cse.c's hash_rtx.

Patch edited by Tim S.
---
 gcc/cselib.c  | 24 +++++++++++++++++++-----
diff --git a/gcc/cselib.c b/gcc/cselib.c
index f453489e12b..03ee8503858 100644
--- a/gcc/cselib.c
+++ b/gcc/cselib.c
@@ -605,14 +605,28 @@ cselib_hash_rtx (rtx x, enum machine_mode mode, int create)
 
       /* Assume there is only one rtx object for any given label.  */
     case LABEL_REF:
-      hash
-	+= ((unsigned) LABEL_REF << 7) + (unsigned long) XEXP (x, 0);
+      /* We don't hash on the address of the CODE_LABEL to avoid bootstrap
+	 differences and differences between each stage's debugging dumps.  */
+      hash += (((unsigned int) LABEL_REF << 7)
+	       + CODE_LABEL_NUMBER (XEXP (x, 0)));
       return hash ? hash : (unsigned int) LABEL_REF;
 
     case SYMBOL_REF:
-      hash
-	+= ((unsigned) SYMBOL_REF << 7) + (unsigned long) XSTR (x, 0);
-      return hash ? hash : (unsigned int) SYMBOL_REF;
+      {
+	/* Don't hash on the symbol's address to avoid bootstrap differences.
+	   Different hash values may cause expressions to be recorded in
+	   different orders and thus different registers to be used in the
+	   final assembler.  This also avoids differences in the dump files
+	   between various stages.  */
+	unsigned int h = 0;
+	const unsigned char *p = (const unsigned char *) XSTR (x, 0);
+
+	while (*p)
+	  h += (h << 7) + *p++; /* ??? revisit */
+
+	hash += ((unsigned int) SYMBOL_REF << 7) + h;
+	return hash ? hash : (unsigned int) SYMBOL_REF;
+      }
 
     case PRE_DEC:
     case PRE_INC:
-- 
